; The core of the system is written in assembler for speed
; You can link devices from Arduino-land by writing a word
; which uses a SYSCALL instruction to call a function you
; supply in C to wrap the Ardino library
;
; Memory Map
; You should redefine this for your device depending on how
; much memory you have available
;
#SYSTEM:   0x0000 ; System reset vector
#INNER:    0x0100 ; Inner interpreter starts here
#MEMSIZE:  0x2000 ; Reserve 8K-bytes for Forth
#FENCE:    0x13F2 ; Last word in the ROM
#RAMSTART: 0x1400 ; Variables grow up from here
#VARSTART: 0x2000 ; Variables grow up from here
#SPTOP:    0x3800 ; Data stack pointer grows down from here
#RSTOP:    0x3ffe ; And the return stack from here
                  ; This gives both stacks 2K bytes
#LBUF_LEN:  128   ; Maximum length of the line buffer in chars
#BASE_DEC: 10
#BASE_HEX: 16
#BASE_BIN: 2

; The predefined SYSCALLs
#SYSCALL_DEBUG: 0
#SYSCALL_TYPE: 1
#SYSCALL_TYPELN: 2
#SYSCALL_DOT: 3
#SYSCALL_GETC: 4
#SYSCALL_PUTC: 5
#SYSCALL_INLINE: 6
#SYSCALL_FLUSH: 7
#SYSCALL_NUMBER: 8
#SYSCALL_H_AT: 9
#SYSCALL_H_STORE: 10
#SYSCALL_D_ADD: 11
#SYSCALL_D_SUB: 12
#SYSCALL_D_MUL: 13
#SYSCALL_D_DIV: 14
#SYSCALL_D_SR: 15
#SYSCALL_D_SL: 16
#SYSCALL_D_AND: 17
#SYSCALL_D_OR: 18
#SYSCALL_D_INVERT: 19
#SYSCALL_DOT_C: 20
#SYSCALL_FOPEN: 21
#SYSCALL_FCLOSE: 22
#SYSCALL_FREAD: 23


#MODE_EXECUTE: 0
#MODE_COMPILE: 1
#STATE_NOT_FOUND: 0
#STATE_FOUND: 1

#HEADER_MASK: 0x1fff
#HEADER_HEADER_BIT: 15
#HEADER_SCOPE_BITS: 13
#HEADER_SCOPE_NORMAL: 0
#HEADER_SCOPE_RUNTIME: 1
#HEADER_SCOPE_IMMEDIATE: 2
#HEADER_SCOPE_EXECUTIVE: 3
#HEADER_IMMEDIATE: 0xc000
#HEADER_RUNTIME: 0xa000
#HEADER_EXECUTIVE: 0xe000

.ORG #VARSTART
%BASE: 2               ; Current system numeric base
%LBUF_IDX: 2           ; Current line buffer byte pointer
%LBUF_END: 2           ; Address of the last character in the buffer
%LBUF_DATA: #LBUF_LEN  ; Line buffer data
%DICTIONARY_POINTER: 2
%CONTEXT: 2
%CURRENT: 2
%CORE: 2
%MODE: 2
%STATE: 2

.ORG #SYSTEM ; Start vector is at address 0
START: 

  MOVIL A,#RAMSTART         ; Address of the cold-boot end of the dictionary
  MOVIL B,%DICTIONARY_POINTER
  ST B,A

  MOVIL A,CORE_VOCABULARY ; Last word in the dictionary
  MOVIL B,%CORE
  ST B,A

  MOVIL A,%CURRENT
  ST A,B
  MOVIL A,%CONTEXT
  ST A,B

STAR_RESTART: ; Restart from here if a runtime error occurs
  MOVIL SP,#SPTOP
  MOVIL RS,#RSTOP

  ; Set LBUF_END to LBUF_DATA
  MOVIL A,%LBUF_DATA
  MOVIL B,%LBUF_END
  ST B,A

  ; Start with BASE set to HEX
  MOVIL A,#BASE_HEX
  MOVIL B,%BASE
  ST B,A

  ; Execute mode
  MOVIL A,#MODE_EXECUTE
  MOVIL B,%MODE
  ST B,A

  MOVIL A,#STATE_NOT_FOUND
  MOVIL B,%STATE
  ST B,A

  MOVIL A,0x0a
  MOVIL B,%BASE
  ST B,A

  MOVIL I,OUTER_CA
  JP NEXT

.ORG #INNER ; Beginning of the inner interpreter
COLON: 
  PUSHR I
  MOV I,WA
  JR NEXT
SEMI:
  .DATA SEMICA ; I.e. the address of the next word
SEMICA:
  POPR I
NEXT:
  LD WA,I ; WA <- (I)
  ADDI I,2
RUN:
  LD CA,WA
  ADDI WA,2
  MOV PC,CA

MESSAGES: ; SYSTEM MESSAGES LIVE HERE
MSG_HELLO:          .DATA 22 .SDATA "Hello! I'm a TIL :-) >"
MSG_UNKNOWN_TOKEN:  .DATA 14 .SDATA "Unknown token "
MSG_COMPILE_ONLY:   .DATA 39 .SDATA "Compile-time words forbidden at runtime"
MSG_RUNTIME_ONLY:   .DATA 39 .SDATA "Runtime words forbidden at compile-time"
MSG_SYSTEM_ERROR:   .DATA 12 .SDATA "System error"
MSG_WORD_NOT_FOUND: .DATA 14 .SDATA "Word not found"
MSG_PROMPT:         .DATA  6 .SDATA " OK >>"
MSG_SP_UNDERFLOW:   .DATA 15 .SDATA "Stack underflow"
MSG_RS_UNDERFLOW:   .DATA 22 .SDATA "Return stack underflow"

BUILDS:
  .N "<BUILDS"
  .DATA 0
BUILDS_WA: .DATA COLON
BUILDS_CA:
  .DATA STAR_HASH_WA
  .DATA 0
  .DATA CONSTANT_WA
  .DATA SEMI

DOES:
  .N "DOES>"
  .DATA BUILDS
DOES_WA: .DATA COLON
DOES_CA:
  .DATA RFROM_WA
  .DATA ENTRY_WA
  .DATA WA_TO_CB_WA
  .DATA STORE_WA
  .DATA SCODE_WA
  PUSHR I
  LD I,WA
  ADDI WA,2
  PUSHD WA
  JP NEXT

IMMEDIATE:
  .N "IMMEDIATE"
  .DATA DOES
IMMEDIATE_WA: .DATA IMMEDIATE_CA
IMMEDIATE_CA:
  MOVIL A,%CURRENT
  LD B,A ; point to vocab
  LD B,B ; point to word
  LD A,B ; get the word length
  MOVIL R0,#HEADER_IMMEDIATE
  OR A,R0 ; Set the immediate bit
  ST B,A
  JP NEXT

RUNTIME:
  .N "RUNTIME"
  .DATA IMMEDIATE
RUNTIME_WA: .DATA RUNTIME_CA
RUNTIME_CA:
  MOVIL A,%CURRENT
  LD B,A ; point to vocab
  LD B,B ; point to word
  LD A,B ; get the word length
  MOVIL R0,#HEADER_RUNTIME
  OR A,R0 ; Set the runtime bit
  ST B,A
  JP NEXT


EXECUTIVE:
  .N "EXECUTIVE"
  .DATA RUNTIME
EXECUTIVE_WA: .DATA EXECUTIVE_CA
EXECUTIVE_CA:
  MOVIL A,%CURRENT
  LD B,A ; point to vocab
  LD B,B ; point to word
  LD A,B ; get the word length
  MOVIL R0,#HEADER_EXECUTIVE
  OR A,R0 ; Set the immediate and runtime bits
  ST B,A
  JP NEXT

VOCABULARY:
  .N "VOCABULARY"
  .DATA EXECUTIVE
VOCABULARY_WA: .DATA COLON
VOCABULARY_CA:
  .DATA BUILDS_WA
  .DATA ENTRY_WA
  .DATA COMMA_WA
  .DATA DOES_WA
  .DATA CONTEXT_WA
  .DATA STORE_WA
  .DATA SEMI

CORE:   ; My definition. Should really be as defined using VOCABULARY
        ; But I don't understand how that works yet
        ; And it needs to store values in ram, not the code-body of the word
  .N "CODE"
  .DATA VOCABULARY
CORE_WA: .DATA CORE_CA
CORE_CA:
  MOVIL A,%CORE
  MOVIL B,%CONTEXT
  LD B,A
  JP NEXT

STAR_LIT:
  .N "*\""
  .DATA CORE
STAR_LIT_WA: .DATA STAR_LIT_CA
STAR_LIT_CA:
  LD A,I ; Length to A
  PUSHD I
  SYSCALL #SYSCALL_TYPE
  ADD I,A
  ADDI I,3
  CLRI I,0 ; Word align
  JP NEXT

BREAKPOINT:
  .N "BREAKPOINT"
  .DATA STAR_LIT
BREAKPOINT_WA: .DATA BREAKPOINT_CA
BREAKPOINT_CA:
  SYSCALL #SYSCALL_DEBUG 
  JP NEXT

RESTART:
  .N "RESTART"
  .DATA BREAKPOINT
RESTART_WA: .DATA STAR_RESTART

; Test the stacks for underflow
; If there is underflow then print a message and restart
STAR_STACK:
  .N "*STACK"
  .DATA RESTART
STAR_STACK_WA: .DATA STAR_STACK_CA
STAR_STACK_CA:
  MOVIL R0,#SPTOP
  SUB R0,SP
  JR[NC] STAR_STACK_CHECK_RS
  MOVIL SP,#SPTOP
  MOVIL A,MSG_SP_UNDERFLOW
  PUSHD A
  SYSCALL #SYSCALL_TYPELN
STAR_STACK_CHECK_RS:
  MOVIL R0,#RSTOP
  SUB R0,RS
  JR[NC] STAR_STACK_OK
  MOVIL A,MSG_RS_UNDERFLOW    
  PUSHD A
  SYSCALL #SYSCALL_TYPELN
  JP STAR_RESTART
STAR_STACK_OK:
  JP NEXT

TYPE:
  .N "TYPE"  
  .DATA STAR_STACK   
TYPE_WA:
  .DATA TYPE_CA    ; This is the word address of TYPE
TYPE_CA:             ; The Code address
  SYSCALL #SYSCALL_TYPE
  JP NEXT

TYPELN:
  .N "TYPELN"     ; And the string's characters
  .DATA TYPE   
TYPELN_WA:
  .DATA TYPELN_CA    ; This is the word address of TYPE
TYPELN_CA:             ; The Code address
  SYSCALL #SYSCALL_TYPELN
  JP NEXT

EMIT:
  .N "EMIT"
  .DATA TYPELN
EMIT_WA: .DATA EMIT_CA
EMIT_CA:
  SYSCALL #SYSCALL_PUTC
  JP NEXT

MESSAGE: ; Print a system message ( n -- )
  .N "MESSAGE"
  .DATA EMIT
MESSAGE_WA: .DATA MESSAGE_CA
MESSAGE_CA:
  POPD A                ; Message number n in A (0-based)
  MOVIL B,MESSAGES       ; B holds the message address
MESSAGE_LOOP:
  AND A,A               ; Is this the message we're looking for?
  JR[Z] MESSAGE_FOUND
  LD R0,B               ; Get the length of the message
  ADD B,R0              ; Add to the address
  ADDI B,3
  CLRI B,0               ; Word-align
  ADDI A,-1             ; Decrement A
  JR MESSAGE_LOOP
MESSAGE_FOUND:
  PUSHD B               ; Message address to the stack
  SYSCALL #SYSCALL_TYPE
  JP NEXT

DOT:  ; The Forth word "." to print the value on the top of the stack
  .N "."
  .DATA MESSAGE
DOT_WA:
  .DATA DOT_CA
DOT_CA:
  MOVIL A,%BASE
  LD B,A     ; Current base in B
  PUSHD B      ; Push it to the stack
  SYSCALL #SYSCALL_DOT
  JP NEXT

DOT_C:  ; The Forth word ".C" to print the value on the top of the stack
  .N ".C"
  .DATA DOT
DOT_C_WA:
  .DATA DOT_C_CA
DOT_C_CA:
  MOVIL A,%BASE
  LD B,A     ; Current base in B
  PUSHD B      ; Push it to the stack
  SYSCALL #SYSCALL_DOT_C
  JP NEXT

MODE:
  .N "MODE"
  .DATA DOT_C
MODE_WA:
  .DATA MODE_CA
MODE_CA:
  MOVIL A,%MODE
  PUSHD A
  JP NEXT

BASE:
  .N "BASE"
  .DATA MODE
BASE_WA: .DATA BASE_CA
BASE_CA:
  MOVIL A,%BASE
  PUSHD A
  JP NEXT

HEX:
  .N "HEX"
  .DATA BASE
HEX_WA: .DATA HEX_CA
HEX_CA:
  MOVIL A,%BASE
  MOVBI 0x10
  ST A,B
  JP NEXT

DECIMAL:
  .N "DECIMAL"
  .DATA HEX
DECIMAL_WA: .DATA DECIMAL_CA
DECIMAL_CA:
  MOVIL A,%BASE
  MOVBI 10
  ST A,B
  JP NEXT

BINARY:
  .N "BINARY"
  .DATA DECIMAL
BINARY_WA: .DATA BINARY_CA
BINARY_CA:
  MOVIL A,%BASE
  MOVBI 2
  ST A,B
  JP NEXT

AT:
  .N "@"
  .DATA BINARY
AT_WA:
  .DATA AT_CA
AT_CA:
  POPD A
  LD A,A
  PUSHD A
  JP NEXT

C_AT:
  .N "C@"
  .DATA AT
C_AT_WA:
  .DATA C_AT_CA
C_AT_CA:
  POPD A
  LD B,A
  MOVIL A,0xff
  AND B,A
  PUSHD B
  JP NEXT

STORE:
  .N "!"
  .DATA C_AT
STORE_WA:
  .DATA STORE_CA
STORE_CA:
  POPD A
  POPD B
  ST A,B
  JP NEXT

H_AT:
  .N "H@"
  .DATA STORE
H_AT_WA: .DATA H_AT_CA
H_AT_CA:
  SYSCALL #SYSCALL_H_AT
  JP NEXT

H_STORE:
  .N "H!"
  .DATA H_AT
H_STORE_WA: .DATA H_STORE_CA
H_STORE_CA:
  SYSCALL #SYSCALL_H_STORE
  JP NEXT

D_AT:
  .N "D@"
  .DATA H_STORE
D_AT_WA: .DATA D_AT_CA
D_AT_CA:
  ; ( address -- double-data )
  POPD R0 ; Address
  LD R1,R0 ; Low word
  ADDI R0,2
  LD R2,R0
  PUSHD R1
  PUSHD R2
  JP NEXT

D_STORE:
  .N "D!"
  .DATA D_AT
D_STORE_WA: .DATA D_STORE_CA
D_STORE_CA:
; ( double-data address -- )
  POPD R0 ; address
  POPD R1 ; DH
  POPD R2 ; DL 
  ST R0,R2
  ADDI R0,2
  ST R0,R1
  JP NEXT

D_ADD:
  .N "D+"
  .DATA D_STORE
D_ADD_WA: .DATA D_ADD_CA
D_ADD_CA:
  SYSCALL #SYSCALL_D_ADD
  JP NEXT


D_AND:
  .N "DAND"
  .DATA D_ADD
D_AND_WA: .DATA D_AND_CA
D_AND_CA:
  SYSCALL #SYSCALL_D_AND
  JP NEXT


D_OR:
  .N "DOR"
  .DATA D_AND
D_OR_WA: .DATA D_OR_CA
D_OR_CA:
  SYSCALL #SYSCALL_D_OR
  JP NEXT


D_INVERT:
  .N "DINVERT"
  .DATA D_OR
D_INVERT_WA: .DATA D_INVERT_CA
D_INVERT_CA:
  SYSCALL #SYSCALL_D_INVERT
  JP NEXT

D_SUB:
  .N "D-"
  .DATA D_INVERT
D_SUB_WA: .DATA D_SUB_CA
D_SUB_CA:
  SYSCALL #SYSCALL_D_SUB
  JP NEXT

D_MUL:
  .N "D*"
  .DATA D_SUB
D_MUL_WA: .DATA D_MUL_CA
D_MUL_CA:
  SYSCALL #SYSCALL_D_MUL
  JP NEXT

D_DIV:
  .N "D/"
  .DATA D_MUL
D_DIV_WA: .DATA D_DIV_CA
D_DIV_CA:
  SYSCALL #SYSCALL_D_DIV
  JP NEXT

D_SR:
  .N "D>>"
  .DATA D_DIV
D_SR_WA: .DATA D_SR_CA
D_SR_CA:
  SYSCALL #SYSCALL_D_SR
  JP NEXT

D_SL:
  .N "D<<"
  .DATA D_SR
D_SL_WA: .DATA D_SL_CA
D_SL_CA:
  SYSCALL #SYSCALL_D_SL
  JP NEXT

D_SWAP:
  .N "DSWAP"
  .DATA D_SL
D_SWAP_WA: .DATA D_SWAP_CA
D_SWAP_CA:
  POPD R0 ; H1
  POPD R1 ; L1
  POPD R2 ; H2
  POPD R3 ; L2
  PUSHD R1 ; L1
  PUSHD R0 ; L1 H1
  PUSHD R3 ; L1 H1 L2
  PUSHD R2 ; L1 H1 L2 H2
  JP NEXT

D_DUP:
  .N "DDUP"
  .DATA D_SWAP
D_DUP_WA: .DATA D_DUP_CA
D_DUP_CA:
  POPD R0 ; H1
  POPD R1 ; L1
  PUSHD R1 ; L1
  PUSHD R0 ; L1 H1
  PUSHD R1 ; L1
  PUSHD R0 ; L1 H1
  JP NEXT


PLUS:
  .N "+"
  .DATA D_DUP
PLUS_WA: 
  .DATA PLUS_CA
PLUS_CA:
  POPD A
  POPD B
  ADD A,B
  PUSHD A
  JP NEXT

PLUS_STORE:
  .N "+!"
  .DATA PLUS
PLUS_STORE_WA: .DATA PLUS_STORE_CA
PLUS_STORE_CA:
  POPD A
  POPD B
  LD R0,A
  ADD R0,B
  ST A,R0
  JP NEXT

MINUS:
  .N "-"
  .DATA PLUS_STORE
MINUS_WA: 
  .DATA MINUS_CA
MINUS_CA:
  POPD A
  POPD B
  SUB B,A
  PUSHD B
  JP NEXT

TIMES:
  .N "*"
  .DATA MINUS
TIMES_WA: 
  .DATA TIMES_CA
TIMES_CA:
  POPD A
  POPD B
  MUL B,A
  PUSHD B
  JP NEXT

DIV:
  .N "/"
  .DATA TIMES
DIV_WA: 
  .DATA DIV_CA
DIV_CA:
  POPD A
  POPD B
  DIV B,A
  PUSHD B
  JP NEXT

AND:
  .N "AND"
  .DATA DIV
AND_WA: 
  .DATA AND_CA
AND_CA:
  POPD A
  POPD B
  AND B,A
  PUSHD B
  JP NEXT

OR:
  .N "OR"
  .DATA AND
OR_WA: .DATA OR_CA
OR_CA:
  POPD A
  POPD B
  OR A,B
  PUSHD A
  JP NEXT

NOT:
  .N "NOT"
  .DATA OR
NOT_WA: .DATA NOT_CA
NOT_CA:
  POPD A
  CMPI A,0
  JR[Z] NOT_IS_ZERO
  MOVI A,0 ; invert
  PUSHD A
  JP NEXT
NOT_IS_ZERO:
  MOVI A,1
  PUSHD A
  JP NEXT

INVERT:
  .N "INVERT"
  .DATA NOT
INVERT_WA: .DATA INVERT_CA
INVERT_CA:
  POPD A
  NOT A
  PUSHD A
  JP NEXT

EQUALS:
  .N "="
  .DATA INVERT
EQUALS_WA: .DATA EQUALS_CA
EQUALS_CA:
  POPD A
  POPD B
  CMP A,B
  JR[NZ] EQUALS_FALSE
  MOVI A,1
  PUSHD A
  JP NEXT
EQUALS_FALSE:
  MOVI A,0
  PUSHD A
  JP NEXT

NOT_EQUALS:
  .N "!="
  .DATA EQUALS
NOT_EQUALS_WA: .DATA NOT_EQUALS_CA
NOT_EQUALS_CA:
  POPD A
  POPD B
  CMP A,B
  JR[NZ] NOT_EQUALS_TRUE
  MOVI A,0
  PUSHD A
  JP NEXT
NOT_EQUALS_TRUE:
  MOVI A,1
  PUSHD A
  JP NEXT

GT:
  .N ">"
  .DATA NOT_EQUALS
GT_WA: .DATA GT_CA
GT_CA:
  POPD A
  POPD B
  JR LT_COMPARE

GTE:
  .N ">="
  .DATA GT
GTE_WA: .DATA GTE_CA
GTE_CA:
  POPD A
  POPD B
  JR LTE_COMPARE

; Default less-than works for signed numbers
LT:
  .N "<"
  .DATA GTE
LT_WA: .DATA LT_CA
LT_CA:
  POPD B
  POPD A
LT_COMPARE:
  CMP A,B
  JR[Z] LT_FALSE
LT_NOT_EQUAL:
  MOV R0,A
  XOR R0,B ; Compare signs
  BITI R0,15
  JR[Z] LT_SAME_SIGN
  ; Signs are different, so the negative one is <
  BITI A,15
  JR[Z] LT_FALSE
  JR LT_TRUE

LT_SAME_SIGN:
  ; We can just do a normal compare
  CMP A,B
  JR[C] LT_TRUE

LT_FALSE:
  MOVI A,0
  PUSHD A
  JP NEXT

LT_TRUE:
  MOVI A,1
  PUSHD A
  JP NEXT


LTE:
  .N "<="
  .DATA LT
LTE_WA: .DATA LTE_CA
LTE_CA:
  POPD B
  POPD A
LTE_COMPARE:
  CMP A,B
  JR[Z] LT_TRUE
  JR LT_NOT_EQUAL


; Unsigned comparisons
ULT:
  .N "U<"
  .DATA LTE
ULT_WA: .DATA ULT_CA
ULT_CA:
  POPD B
  POPD A
  CMP A,B
  JR[C] ULT_TRUE
  MOVI A,0
  PUSHD A
  JP NEXT
ULT_TRUE:
  MOVI A,1
  PUSHD A
  JP NEXT  

; Unsigned comparisons
UGT:
  .N "U>"
  .DATA ULT
UGT_WA: .DATA UGT_CA
UGT_CA:
  POPD A
  POPD B
  CMP A,B
  JR[C] UGT_TRUE
  MOVI A,0
  PUSHD A
  JP NEXT
UGT_TRUE:
  MOVI A,1
  PUSHD A
  JP NEXT  

SL:
  .N "<<"
  .DATA UGT
SL_WA: .DATA SL_CA
SL_CA:
  POPD B
  POPD A
  SL A,B
  PUSHD A
  JP NEXT

SR:
  .N ">>"
  .DATA SL
SR_WA: .DATA SR_CA
SR_CA:
  POPD B
  POPD A
  SR A,B
  PUSHD A
  JP NEXT

ALIGN:
  .N "ALIGN"
  .DATA SR
ALIGN_WA:
  .DATA ALIGN_CA
ALIGN_CA:
  POPD A
  ADDI A,1
  CLRI A,0
  PUSHD A
  JP NEXT

DUP:
  .N "DUP"
  .DATA ALIGN
DUP_WA: .DATA DUP_CA
DUP_CA:
  POPD A
  PUSHD A
  PUSHD A
  JP NEXT

; ( 1 2 3 -- 2 3 1 )
ROT:
  .N "ROT"
  .DATA DUP
ROT_WA: .DATA ROT_CA
ROT_CA:
  POPD R3
  POPD R2
  POPD R1
  PUSHD R2
  PUSHD R3
  PUSHD R1
  JP NEXT

; ( 1 2 3 -- 3 1 2 )
LROT:
  .N "LROT"
  .DATA ROT
LROT_WA: .DATA LROT_CA
LROT_CA:
  POPD R3
  POPD R2
  POPD R1
  PUSHD R3
  PUSHD R1
  PUSHD R2
  JP NEXT

; ( xn .. x0 u -- xn .. x0 xu)
PICK:
  .N "PICK"
  .DATA LROT
PICK_WA: .DATA PICK_CA
PICK_CA:
  POPD R0
  MOV R1,SP
  ADD R1,R0
  ADD R1,R0 ; *2 to word-align
  ADDI R1,2 ; 
  LD R2,R1
  PUSHD R2
  JP NEXT

SWAP:
  .N "SWAP"
  .DATA PICK
SWAP_WA: .DATA SWAP_CA
SWAP_CA:
  POPD R0
  POPD R1
  PUSHD R0
  PUSHD R1
  JP NEXT

DROP:
  .N "DROP"
  .DATA SWAP
DROP_WA:
  .DATA DROP_CA
DROP_CA:
  POPD A
  JP NEXT

OVER:
  .N "OVER"
  .DATA DROP
OVER_WA: .DATA OVER_CA
OVER_CA:
  POPD A
  POPD B
  PUSHD B
  PUSHD A
  PUSHD B
  JP NEXT

INDEX_I:
  .N "I"
  .DATA OVER
INDEX_I_WA: .DATA INDEX_I_CA
INDEX_I_CA:
  POPR A
  PUSHR A
  PUSHD A
  JP NEXT

INDEX_J:
  .N "J"
  .DATA INDEX_I
INDEX_J_WA: .DATA INDEX_J_CA
INDEX_J_CA:
  LDAX RS,3 ; words
  PUSHD A
  JP NEXT

INDEX_K:
  .N "K"
  .DATA INDEX_J
INDEX_K_WA: .DATA INDEX_K_CA
INDEX_K_CA:
  LDAX RS,5 ; words
  PUSHD A
  JP NEXT

COMMA:
  .N ","
  .DATA INDEX_K
COMMA_WA: .DATA COMMA_CA
COMMA_CA:
  POPD A
  MOVIL B,%DICTIONARY_POINTER
  LD B,B
  ST B,A
  ADDI B,2
  MOVIL A,%DICTIONARY_POINTER
  ST A,B
  JP NEXT

FLUSH:  ; Flush stdout
  .N "FLUSH"
  .DATA COMMA
FLUSH_WA:
    .DATA FLUSH_CA
FLUSH_CA:
    SYSCALL #SYSCALL_FLUSH
    JP NEXT



ASPACE:           ; Forth word to push a space char to the stack
  .N "ASPACE"
  .DATA FLUSH
ASPACE_WA:
  .DATA ASPACE_CA
ASPACE_CA:
  MOVAI 0x20
  PUSHD A
  JP NEXT

ONEPLUS:
  .N "1+"
  .DATA ASPACE
ONEPLUS_WA: .DATA ONEPLUS_CA
ONEPLUS_CA:
  POPD A
  ADDI A,1
  PUSHD A
  JP NEXT

TWOPLUS:
  .N "2+"
  .DATA ONEPLUS
TWOPLUS_WA: .DATA TWOPLUS_CA
TWOPLUS_CA:
  POPD A
  ADDI A,2
  PUSHD A
  JP NEXT

ONEMINUS:
  .N "1-"
  .DATA TWOPLUS
ONEMINUS_WA: .DATA ONEMINUS_CA
ONEMINUS_CA:
  POPD A
  ADDI A,-1
  PUSHD A
  JP NEXT

TWOMINUS:
  .N "2-"
  .DATA ONEMINUS
TWOMINUS_WA: .DATA TWOMINUS_CA
TWOMINUS_CA:
  POPD A
  ADDI A,-2
  PUSHD A
  JP NEXT

SCODE:
  .N "SCODE"
  .DATA TWOMINUS
SCODE_WA:
  .DATA COLON
SCODE_CA:
  .DATA RFROM_WA
  .DATA CASTORE_WA
  .DATA SEMI

RFROM:
  .N "R>"
  .DATA SCODE
RFROM_WA:
  .DATA RFROM_CA
RFROM_CA:
  POPR A
  PUSHD A
  JP NEXT

TOR:
  .N ">R"
  .DATA RFROM
TOR_WA:
  .DATA TOR_CA
TOR_CA:
  POPD A
  PUSHR A
  JP NEXT

ENTRY:
  .N "ENTRY"
  .DATA TOR
ENTRY_WA:
  .DATA COLON
ENTRY_CA:
  .DATA CURRENT_WA
  .DATA AT_WA
  .DATA AT_WA
  .DATA SEMI

DP:
  .N "DP"
  .DATA ENTRY
DP_WA: .DATA DP_CA
DP_CA:
  MOVIL A,%DICTIONARY_POINTER
  PUSHD A
  JP NEXT

DP_STORE:
  .N "DP!"
  .DATA DP
DP_STORE_WA: .DATA DP_STORE_CA
DP_STORE_CA:
  MOVIL A,%DICTIONARY_POINTER
  POPD B
  ST A,B
  JP NEXT

TWO_PLUS:
  .N "2+"
  .DATA DP_STORE
TWO_PLUS_WA: .DATA TWO_PLUS_CA
TWO_PLUS_CA:
  POPD A
  ADDI A,2
  PUSHD A
  JP NEXT

WA_TO_LA:
  .N "WA>LA"
  .DATA TWO_PLUS
WA_TO_LA_WA: .DATA WA_TO_LA_CA
WA_TO_LA_CA:
  ; ( wa -- ca )
  POPD A
  MOV B,A
  LD A,B ; Length to A
  MOVIL R0, 0x1fff
  AND A,R0
  ADD A,B
  ADDI A,3
  CLRI A,0 ; Word-align
  PUSHD A
  JP NEXT

WA_TO_CA:
  .N "WA>CA"
  .DATA WA_TO_LA
WA_TO_CA_WA: .DATA WA_TO_CA_CA
WA_TO_CA_CA:
  ; ( wa -- ca )
  POPD A
  MOV B,A
  LD A,B ; Length to A
  MOVIL R0, 0x1fff
  AND A,R0
  ADD A,B
  ADDI A,5
  CLRI A,0 ; Word-align
  PUSHD A
  JP NEXT

WA_TO_CB:
  .N "WA>CB"
  .DATA WA_TO_CA
WA_TO_CB_WA: .DATA WA_TO_CB_CA
WA_TO_CB_CA:
  ; ( wa -- cb )
  POPD A
  MOV B,A
  LD A,B ; Length to A
  MOVIL R0, 0x1fff
  AND A,R0
  ADD A,B
  ADDI A,7
  CLRI A,0 ; Word-align
  PUSHD A
  JP NEXT

;  : CA>WA 
;    ( try to convert a CA to a Word address )
;    ( put a sanity check in place in case we can't find the WA )
;    2 - ( skip over the link word )
;    64
;    SWAP
;    BEGIN
;        SWAP DUP 0 = NOT 
;        ( addr count )
;        IF
;            ( OK to continue )
;            1 - ( addr count-- )
;            SWAP 
;            2 - DUP @ 0x8000 AND ( got to the header? )
;            ( count addr flag)
;            IF 1 ELSE 0 THEN
;        ELSE
;            DROP DROP 0 _UNKNOWN 0
;        THEN
;    ( count addr flag )
;    UNTIL
;    SWAP DROP
; ;

CA_TO_WA:
  .N "CA>WA"
  .DATA WA_TO_CB
CA_TO_WA_WA: .DATA COLON
CA_TO_WA_CA:
  .DATA STAR_HASH_WA .DATA 2 .DATA MINUS_WA
  .DATA STAR_HASH_WA .DATA 64 .DATA SWAP_WA
CA_TO_WA_LOOP:
  .DATA SWAP_WA .DATA DUP_WA .DATA STAR_HASH_WA .DATA 0
  .DATA EQUALS_WA .DATA NOT_WA
  .DATA STAR_IF_WA .DATA STAR_IF_LEAVE
  .DATA STAR_HASH_WA .DATA 1 .DATA MINUS_WA
  .DATA SWAP_WA
  .DATA STAR_HASH_WA .DATA 2 .DATA MINUS_WA 
  .DATA DUP_WA .DATA AT_WA
  .DATA STAR_HASH_WA .DATA 0x8000 .DATA AND_WA
  .DATA STAR_IF_WA .DATA CA_TO_WA_NOT_A_HEADER
  .DATA STAR_HASH_WA .DATA 1
  .DATA STAR_ELSE_WA .DATA CA_TO_WA_HEADER_THEN
CA_TO_WA_NOT_A_HEADER:
  .DATA STAR_HASH_WA .DATA 0
CA_TO_WA_HEADER_THEN:
  .DATA STAR_ELSE_WA .DATA CA_TO_WA_UNTIL
STAR_IF_LEAVE:
  .DATA DROP_WA .DATA DROP_WA
  .DATA STAR_HASH_WA .DATA 0
  .DATA STAR_LIT_WA .DATA 13 .SDATA "-- UNKNOWN --"
  .DATA STAR_HASH_WA .DATA 0
CA_TO_WA_UNTIL:
  .DATA STAR_UNTIL_WA
  .DATA CA_TO_WA_LOOP
  .DATA SWAP_WA .DATA DROP_WA
  .DATA SEMI


CREATE:
  .N "CREATE"
  .DATA CA_TO_WA
CREATE_WA: .DATA COLON
CREATE_CA:
  .DATA ENTRY_WA      ;( -- WA of last entry )
  .DATA ASPACE_WA
  .DATA TOKEN_WA      ;( .. -- WA LEN )
  
  .DATA HERE_WA       ;( .. -- WA LEN HERE )
  .DATA CURRENT_WA    
  .DATA AT_WA         ;( .. -- WA LEN HERE [ADDR OF CURRENT VOCAB] )
  .DATA STORE_WA      ;( .. -- WA LEN )

  ; Set the header bit in the word's length
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 0x8000
  .DATA OR_WA
  .DATA HERE_WA
  .DATA STORE_WA
  
  ; Print the defined word
  .DATA HERE_WA
  .DATA DOT_WA .DATA ASPACE_WA .DATA EMIT_WA      ; print the address
  
  .DATA HERE_WA
  .DATA DOT_WORD_WA .DATA ASPACE_WA .DATA EMIT_WA ; print the word
  
  .DATA Q_SP_WA .DATA DOT_WA .DATA CRET_WA        ; print the SP

  ; Bump the DP by the length of the token plus two for the length itself
  .DATA HERE_WA
  .DATA PLUS_WA       ; Add the length
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA      ; now points to link
  .DATA DP_WA
  .DATA STORE_WA      ; update the dictionary pointer

  ; Compile ENTRY
  .DATA COMMA_WA      ; point to the last entry
  .DATA HERE_WA
  .DATA TWO_PLUS_WA
  .DATA COMMA_WA      ; And point CA to here
  .DATA SEMI

SEMICOLON:
; This is an executive word
  .X ";"
  .DATA CREATE
SEMICOLON_WA: .DATA COLON
SEMICOLON_CA:
  .DATA STAR_HASH_WA .DATA SEMI
  .DATA COMMA_WA

  .DATA STAR_HASH_WA
  .DATA 0
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA SEMI

CURRENT:
  .N "CURRENT"
  .DATA SEMICOLON
CURRENT_WA:
  .DATA CURRENT_CA
CURRENT_CA:
  MOVIL A,%CURRENT
  PUSHD A
  JP NEXT

CONTEXT:
  .N "CONTEXT"
  .DATA CURRENT
CONTEXT_WA:
  .DATA CONTEXT_CA
CONTEXT_CA:
  MOVIL A,%CONTEXT
  PUSHD A
  JP NEXT

DEFINITIONS:
  .N "DEFINITIONS"
  .DATA CONTEXT
DEFINITIONS_WA: .DATA COLON
DEFINITIONS_CA:
  .DATA CONTEXT_WA
  .DATA AT_WA
  .DATA CURRENT_WA
  .DATA STORE_WA
  .DATA SEMI

CASTORE:
  .N "CA!"
  .DATA DEFINITIONS
CASTORE_WA:
  .DATA COLON
CASTORE_CA:
  .DATA ENTRY_WA
  .DATA WA_TO_CA_WA
  .DATA STORE_WA
  .DATA SEMI

HERE:
  .N "HERE"
  .DATA CASTORE
HERE_WA: .DATA HERE_CA
HERE_CA:
  MOVIL A,%DICTIONARY_POINTER
  LD B,A
  PUSHD B
  JP NEXT

CONSTANT:
  .N "CONSTANT"
  .DATA HERE
CONSTANT_WA:
  .DATA COLON
CONSTANT_CA:
  .DATA CREATE_WA
  .DATA COMMA_WA
  .DATA SCODE_WA
  LD A,WA
  PUSHD A JP NEXT

HEADER_TO_MODE:
; ( headerWord -- modeBits )
  .N "HEADER-TO-MODE"
  .DATA CONSTANT
HEADER_TO_MODE_WA: .DATA HEADER_TO_MODE_CA
HEADER_TO_MODE_CA:
  POPD A
  MOVIL B,#HEADER_HEADER_BIT
  CLR A,B
  MOVIL B,#HEADER_SCOPE_BITS
  SR A,B
  PUSHD A
  JP NEXT

Q_EXECUTE:
  .N "?EXECUTE"
  .DATA HEADER_TO_MODE
Q_EXECUTE_WA:
  .DATA COLON

  ; This routine expects a NA on the stack from a successful SEARCH
  ; Words can be flagged with the immediate [15] and run-time [14] bits
  ; 00 - Normal word. Mode = 0 => Execute   Mode = 1 => Compile
  ; 01 - Runtime only Mode = 0 => Execute   Mode = 1 => Error
  ; 10 - Immediate    Mode = 0 => Error     Mode = 1 => Execute
  ; 11 - Executive    Mode = 0 => Execute   Mode = 1 => Execute
  ;
  ; DUP
  ; @ 13 >>
  ; MODE @
  ; OR
  ; ( addr flags -- )
  ; 
Q_EXECUTE_CA:
  .DATA DUP_WA           ; ( addr - addr addr )
  .DATA AT_WA            ; (addr addr -- addr len )
  .DATA HEADER_TO_MODE_WA
  .DATA STAR_HASH_WA
  .DATA 2
  .DATA SL_WA            ; Get the bits in 2,1 (addr len -- addr (len>>13))
  .DATA MODE_WA
  .DATA AT_WA            ; Get the mode bit
  .DATA OR_WA            ; AS bit 0

  .DATA DUP_WA           ; ( addr bits -- addr bits bits )
  .DATA STAR_HASH_WA 
  .DATA 0                ; ( . -- addr bits bits 0 )
  .DATA EQUALS_WA        ; ( . -- addr bits EQ )
  .DATA STAR_IF_WA       ; ( . -- addr bits )
  .DATA Q_EXECUTE_1
Q_EXECUTE_NORMAL:
    .DATA DROP_WA        ; ( . -- addr )
    .DATA EXECUTE_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_DONE

Q_EXECUTE_1:  
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 1
  .DATA EQUALS_WA
  .DATA STAR_IF_WA 
  .DATA Q_EXECUTE_2
Q_EXECUTE_COMPILE:
    .DATA DROP_WA
    .DATA WA_TO_CA_WA
    .DATA COMMA_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_DONE

Q_EXECUTE_2:
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 2
  .DATA EQUALS_WA
  .DATA STAR_IF_WA 
  .DATA Q_EXECUTE_3
Q_EXECUTE_RUNTIME:
    .DATA DROP_WA
    .DATA EXECUTE_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_DONE

Q_EXECUTE_3:
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 3
  .DATA EQUALS_WA
  .DATA STAR_IF_WA 
  .DATA Q_EXECUTE_4
Q_EXECUTE_RUNTIME_NOT_ALLOWED:
    .DATA STAR_HASH_WA
    .DATA MSG_RUNTIME_ONLY
    .DATA TYPE_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_FAILED

Q_EXECUTE_4:
  .DATA DUP_WA
  .DATA STAR_HASH_WA .DATA 4
  .DATA EQUALS_WA
  .DATA STAR_IF_WA 
  .DATA Q_EXECUTE_EXECUTIVE
Q_EXECUTE_COMPILETIME_NOT_ALLOWED:
   .DATA STAR_HASH_WA
    .DATA MSG_COMPILE_ONLY
    .DATA TYPE_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_FAILED

Q_EXECUTE_EXECUTIVE:
  .DATA DROP_WA
  .DATA EXECUTE_WA
  .DATA STAR_ELSE_WA 
  .DATA Q_EXECUTE_DONE

Q_EXECUTE_ERROR:
  .DATA STAR_HASH_WA 
  .DATA MSG_SYSTEM_ERROR 
  .DATA TYPE_WA

Q_EXECUTE_FAILED:
  .DATA STAR_HASH_WA
  .DATA 0
  .DATA STAR_ELSE_WA
  .DATA Q_EXECUTE_EXIT

Q_EXECUTE_DONE:
  .DATA STAR_STACK_WA
  .DATA STAR_HASH_WA
  .DATA 1
Q_EXECUTE_EXIT:
  .DATA SEMI

; ( -- num true ) | ( -- false )
Q_NUMBER:
  .N "?NUMBER"
  .DATA Q_EXECUTE
Q_NUMBER_WA: .DATA Q_NUMBER_CA
Q_NUMBER_CA:
  MOVIL A,%DICTIONARY_POINTER
  LD A,A
  PUSHD A
  MOVIL A,%BASE
  LD A,A
  PUSHD A
  SYSCALL #SYSCALL_NUMBER
  JP NEXT

EXECUTE:
  .N "EXECUTE"
  .DATA Q_NUMBER
EXECUTE_WA:
  .DATA EXECUTE_CA
EXECUTE_CA:
  POPD WA ; points to the NA
  MOV A,WA
  LD A,A ; Get the length
  MOVIL B,#HEADER_MASK ; flags
  AND A,B
  ADD WA,A
  ADDI WA,5 ; Skip over the name and link
  CLRI WA,0 ; WOrd-align
  JP RUN

; ( sep - tokenLength )
TOKEN:
  .N "TOKEN"
  .DATA EXECUTE
TOKEN_WA:
  .DATA TOKEN_CA
TOKEN_CA:
  ; Scans for tokens from the input line buffer
  ; The buffer is set up by INLINE
  ; LEN PTR CHARS
  ; Register usage:
  ; A - a character
  ; B - The separator
  ; R0 - Current pointer
  ; R1 - Length of this token
  ; R2 - End of the buffer
  ; R3 - scratch
  ; 

  ; Get the separator
  POPD B

  MOVI R1,0 ; Token length
  MOVI R3,0

  MOVIL R0,%LBUF_IDX
  LD R0,R0

  MOVIL R2,%LBUF_END
  LD R2,R2

  CMP R2,R0
  ; at or past the end of the buffer already?
  JR[Z] TOKEN_END
  JR[C] TOKEN_END

  MOVAI 0x20   ; Put a space in A
  CMP B,A     ; Is the separator a space?
  JR[NZ] TOKEN_TOK  ; No, so start seeking

TOKEN_SKIP:         ; Skip leading spaces
  CMP R2,R0         ; At the end of the buffer?
  JR[Z] TOKEN_DONE
  LD_B A,R0          ; Get the next char
  CMP A,B           ; Is it the separator?
  JR[NZ] TOKEN_TOK
  ADDI R0,1
  JR TOKEN_SKIP  ;

TOKEN_TOK:          ; Start searching for the end token here
  CMP R2,R0
  JR[Z] TOKEN_DONE  ; Did we get to the end of the buffer?
  LD_B A,R0
  CMP A,B
  JR[Z] TOKEN_DONE
  CMPAI 0x0A        ; Or is this a carriage return?
  JR[Z] TOKEN_DONE
  ADDI R0,1         ; idx++
  ADDI R1,1         ; len++
  JR TOKEN_TOK

TOKEN_DONE:
  CMPI R1,0
  JR[Z] TOKEN_END
  ; Move the token to the end of the dictionary
  ; So ?SEARCH can access it
  MOVIL A,%DICTIONARY_POINTER
  LD B,A    ; B Points to the dictionary
  ST B,R1   ; Save the length
  MOV R3,R1 ; Save for later
  ADDI B,2  ; Bump the dictionary pointer
  SUB R0,R1 ; Reset the buffer pointer

TOKEN_MOVE:
  LD_B A,R0
  ST_B B,A
  ADDI R0,1 ; Bump the buffer pointer
  ADDI B,1 ; Bump the dictionary pointer
  ADDI R1,-1 ; Decrement the length
  JR[NZ] TOKEN_MOVE
  ;
  ; And we're done
  ; Save the current pointer
  MOVIL A,%LBUF_IDX
  ADDI R0,1 ; Point past the terminator
  ST A,R0

TOKEN_END:
  ; Leave the token length on the stack
  PUSHD R3
  JP NEXT

; INLINE - Read a line from the terminal
; Move it to the line buffer
; We'll just code this as a syscall for now 
; Returns a flag on the stack - false if no characters were read
; ( bufferAddress -- flag )
INLINE:
    .N "INLINE"
    .DATA TOKEN
INLINE_WA:
    .DATA INLINE_CA
INLINE_CA:
    ; Put the address of the line buffer on the stack
    MOVIL A,%LBUF_IDX
    PUSHD A
    SYSCALL #SYSCALL_INLINE
    JP NEXT

; Push the literal following this word to the stack
; and jump over it
STAR_HASH:
; Compile time only
    .I "*#"
    .DATA INLINE ; Link to INLINE
STAR_HASH_WA:
    .DATA STAR_HASH_CA
STAR_HASH_CA:
    LD A,I
    PUSHD A
    ADDI I,2
    JP NEXT

BEGIN:
; Compile time only
  .I "BEGIN"
  .DATA STAR_HASH
BEGIN_WA: .DATA BEGIN_CA
BEGIN_CA:
  MOVIL A,%DICTIONARY_POINTER
  LD A,A ; current DP
  PUSHD A
  JP NEXT

UNTIL:
; Compile time only
  .I "UNTIL"
  .DATA BEGIN
UNTIL_WA: .DATA UNTIL_CA
UNTIL_CA:
  POPD R0 ; loop address
  MOVIL R1,STAR_UNTIL_WA
  MOVIL R2,%DICTIONARY_POINTER
  LD R3,R2
  ; Compile *UNTIL
  ST R3,R1
  ADDI R3,2
  ST R3,R0
  ADDI R3,2
  ST R2,R3
  JP NEXT

STAR_UNTIL:
; Runime only
  .R "*UNTIL"
  .DATA UNTIL
STAR_UNTIL_WA: .DATA STAR_UNTIL_CA
STAR_UNTIL_CA:
  POPD A ; get the flag
  CMPI A,0
  JR[NZ] STAR_UNTIL_DONE
  LD I,I ; Jump back to the begin
  JP NEXT
STAR_UNTIL_DONE:
  ADDI I,2
  JP NEXT

CASE:
  .I "CASE"
  .DATA STAR_UNTIL
CASE_WA: .DATA COLON
CASE_CA: 
  .DATA STAR_HASH_WA .DATA 0
  .DATA SEMI

; CASE someValue v1 OF ... ENDOF v2 OF ... ENDOF ESAC 
; code *OF a1 ... a1:*ENDOF ax *OF a3 ... a3:*ENDOF ax ax:*ESAC
;         (a0)                    (a2)
; CASE 0 ; Number of OF clauses to the stack
;
; OF    -> ' *OF , HERE ( push here to the stack ) SWAP 1+ ( increment number of clauses )
; ENDOF -> HERE SWAP ! ' *ENDOF , HERE 2 ALLOT 
; 
; OF ( 0 -- a0 1 )             ENDOF ( a1 1 )
; OF ( a1 1 -- a1 2 a2 )       ENDOF ( a1 a3 2 )
; OF ( a1 a3 2 -- a1 a3 3 a4 ) ENDOF ( a1 a3 a5 3 )

CASE_OF:
  .I "OF"
  .DATA CASE
CASE_OF_WA: .DATA CASE_OF_CA
CASE_OF_CA:
; R0 - Address of *OF
; R1 - Address of DP
; R2 - value of DP
; R3 - number of clauses
  .ALIAS R0,*OF
  .ALIAS R1,DP
  .ALIAS R2,*DP
  .ALIAS R3,NUM

  POPD NUM
  ADDI NUM,1
  MOVIL *OF,STAR_OF_WA
  MOVIL DP,%DICTIONARY_POINTER
  LD *DP,DP
  ST *DP,*OF ; Compile *OF
  ADDI *DP,2 ; point to location of jump word
  PUSHD *DP  ; save the location
  PUSHD NUM  ; Number of clauses
  ADDI *DP,2 ; next location for the definition
  ST DP,*DP
  JP NEXT  


ENDOF:
  .I "ENDOF"
  .DATA CASE_OF
ENDOF_WA:
  .DATA ENDOF_CA
ENDOF_CA:
  ; TOS contains the location of the word to use for the IF relative jump
  ; R0 - Address of DP
  ; R1 - Value of DP (HERE)
  ; R2 - location of jump address
  POPD R3 ; Number of clauses
  POPD R2 ; Address of previous *OF + 2
  MOVIL R0,%DICTIONARY_POINTER
  LD R1,R0
  ADDI R1,4
  ST R2,R1   ; Save it in the jump location
  MOVIL A,STAR_OF_ENDOF_WA
  ADDI R1,-4
  ST R1,A  ; Compile to the current definition
  ADDI R1,2
  PUSHD R1
  PUSHD R3
  ADDI R1,2
  ST R0,R1
  JP NEXT

ESAC:
  .I "ESAC"
  .DATA ENDOF
ESAC_WA: .DATA ESAC_CA
ESAC_CA:
  ; number of jump locations to fill in is TOS
  POPD R0
  MOVIL R1,%DICTIONARY_POINTER
  LD R1,R1
  MOVIL R2,STAR_ESAC_WA
  ST R1,R2
  ADDI R1,2
  MOVIL R2,%DICTIONARY_POINTER
  ST R2,R1
  ADDI R1,-2

ESAC_LOOP:
  AND R0,R0
  JR[Z] ESAC_LOOP_DONE
  ADDI R0,-1
  POPD R2
  ST R2,R1
  JR ESAC_LOOP

ESAC_LOOP_DONE:
  JP NEXT


STAR_OF:
  .R "*OF"
  .DATA ESAC
STAR_OF_WA:
  .DATA STAR_OF_CA
STAR_OF_CA:
; ( v1 v2 -- v1 )
  POPD A 
  POPD B
  CMP A,B
  JR[Z] STAR_OF_RUN
  PUSHD B
  LD I,I ; Jump to after the *ENDOF
  JP NEXT
STAR_OF_RUN:
  ADDI I,2
  JP NEXT

STAR_OF_ENDOF:
  .R "*OF_ENDOF"
  .DATA STAR_OF
STAR_OF_ENDOF_WA:
  .DATA STAR_OF_ENDOF_CA
STAR_OF_ENDOF_CA:
  LD I,I ; Jump to the *ESAC
  JP NEXT

STAR_ESAC:
  .N "*ESAC"
  .DATA STAR_OF_ENDOF
STAR_ESAC_WA: .DATA STAR_ESAC_CA
STAR_ESAC_CA:
  JP NEXT


IF:
  .I "IF"
  .DATA STAR_ESAC
IF_WA:
  .DATA IF_CA
IF_CA:
; R0 - Address of *IF
; R1 - Address of DP
; R2 - value of DP
  MOVIL R0,STAR_IF_WA
  MOVIL R1,%DICTIONARY_POINTER
  LD R2,R1
  ST R2,R0 ; Compile *IF
  ADDI R2,2 ; point to location of jump word
  PUSHD R2  ; save the location
  ADDI R2,2 ; next location for the definition
  ST R1,R2
  JP NEXT

ELSE:
  .I "ELSE"
  .DATA IF
ELSE_WA:
  .DATA ELSE_CA
ELSE_CA:
  ; TOS contains the location of the word to use for the IF relative jump
  ; R0 - Address of DP
  ; R1 - Value of DP (HERE)
  ; R2 - location of jump address
  POPD R2
  MOVIL R0,%DICTIONARY_POINTER
  LD R1,R0
  ADDI R1,4
  ST R2,R1   ; Save it in the jump location
  MOVIL A,STAR_ELSE_WA
  ADDI R1,-4
  ST R1,A  ; Compile *ELSE to the current definition
  ADDI R1,2
  PUSHD R1
  ADDI R1,2
  ST R0,R1
  JP NEXT

THEN:
  .I "THEN"
  .DATA ELSE
THEN_WA:
  .DATA THEN_CA
THEN_CA:
  ; TOS contains the location of the word to use for the IF/ELSE  jump
  POPD A
  MOVIL B,%DICTIONARY_POINTER ; Current dictionary location to B
  LD B,B
  ST A,B   ; Save it in the jump location
  JP NEXT  

STAR_IF:
  .R "*IF"
  .DATA THEN
STAR_IF_WA:
  .DATA STAR_IF_CA
STAR_IF_CA:
  POPD A ; get the flag
  CMPI A,0
  JR[Z] STAR_ELSE_CA
  ADDI I,2
  JP NEXT

STAR_ELSE:
  .R "*ELSE"
  .DATA STAR_IF
STAR_ELSE_WA:
  .DATA STAR_ELSE_CA
STAR_ELSE_CA:
  LD I,I
  JP NEXT

DO:
  .I "DO"
  .DATA STAR_ELSE
DO_WA: .DATA COLON
DO_CA:
  ; Compile *DO
  .DATA STAR_HASH_WA .DATA STAR_DO_WA
  .DATA COMMA_WA
  ; Push Here to the stack so LOOP cancompile it later
  .DATA HERE_WA
  .DATA SEMI

STAR_DO:
  .R "*DO"
  .DATA DO
STAR_DO_WA: .DATA STAR_DO_CA
STAR_DO_CA:
  POPD A
  POPD B
  PUSHR B
  PUSHR A
  JP NEXT

LOOP:
  .I "LOOP"
  .DATA STAR_DO
LOOP_WA: .DATA COLON
LOOP_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_LOOP_WA
  .DATA COMMA_WA
  .DATA COMMA_WA ; and compile the return address off the stack
  .DATA SEMI

PLUSLOOP:
  .I "+LOOP"
  .DATA LOOP
PLUSLOOP_WA: .DATA COLON
PLUSLOOP_CA:
  .DATA STAR_HASH_WA
  .DATA STAR_PLUSLOOP_WA
  .DATA COMMA_WA
  .DATA COMMA_WA ; and compile the return address off the stack
  .DATA SEMI

STAR_LOOP:
  .R "*LOOP"
  .DATA PLUSLOOP
STAR_LOOP_WA: .DATA STAR_LOOP_CA
STAR_LOOP_CA:
  POPR A ; current index
  POPR B ; end
  ADDI A,1
STAR_CHECK_LOOP:
  CMP A,B 
  JR[C] STAR_LOOP_MORE ; Index not exceeded
  ; Index exceeded, loop is over
  ADDI I,2
  JP NEXT
STAR_LOOP_MORE:
  PUSHR B
  PUSHR A
  LD I,I
  JP NEXT

STAR_PLUSLOOP:
  .R "*+LOOP"
  .DATA STAR_LOOP
STAR_PLUSLOOP_WA: .DATA STAR_PLUSLOOP_CA
STAR_PLUSLOOP_CA:
  POPR A
  POPR B
  POPD R0
  ADD A,R0
  JR STAR_CHECK_LOOP
  ; No return address

Q_SP:
  .N "?SP"
  .DATA STAR_PLUSLOOP
Q_SP_WA: .DATA Q_SP_CA
Q_SP_CA:
  PUSHD SP
  JP NEXT

Q_RS:
  .N "?RS"
  .DATA Q_SP
Q_RS_WA: .DATA Q_RS_CA
Q_RS_CA:
  PUSHD RS
  JP NEXT

; Patch - fixup the dictionary to remove any half-compiled words
PATCH:
  .N "PATCH"
  .DATA Q_RS
PATCH_WA: .DATA COLON
PATCH_CA:
  .DATA MODE_WA
  .DATA AT_WA
  .DATA STAR_IF_WA
  .DATA PATCH_DONE
  .DATA CURRENT_WA
  .DATA AT_WA .DATA AT_WA
  .DATA DUP_WA
  .DATA DP_STORE_WA ; Reset the dictionary pointer
  .DATA WA_TO_LA_WA .DATA AT_WA
  .DATA CURRENT_WA .DATA AT_WA .DATA STORE_WA
PATCH_DONE:
  .DATA RESTART_WA
  .DATA SEMI

OUTER:
    .N "OUTER"
    .DATA PATCH
OUTER_WA:
    .DATA COLON
OUTER_CA:
    .DATA STAR_HASH_WA
    .DATA MSG_HELLO
    .DATA TYPE_WA

OUTER_LOOP:
    .DATA STAR_HASH_WA
    .DATA MSG_PROMPT
    .DATA TYPE_WA
    .DATA INLINE_WA
    .DATA STAR_IF_WA
    .DATA OUTER_LOOP
    .DATA PROCESS_TOKENS_WA
    .DATA STAR_ELSE_WA
    .DATA OUTER_LOOP
    .DATA SEMI

PROCESS_TOKENS:
    .N "PROCESS-TOKENS"
    .DATA OUTER
PROCESS_TOKENS_WA: .DATA COLON
PROCESS_TOKENS_CA:
PROCESS_TOKENS_LOOP:
    .DATA ASPACE_WA
    .DATA TOKEN_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_EXIT ; Just jump back to get another line if no more tokens
    .DATA SEARCH_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NOT_A_WORD
    .DATA Q_EXECUTE_WA ; If the execute failed, discard the rest of the line
    .DATA NOT_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_EXECUTED
    .DATA PATCH_WA
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_EXIT

PROCESS_TOKENS_EXECUTED:
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_LOOP

PROCESS_TOKENS_NOT_A_WORD:
    .DATA Q_NUMBER_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NOT_A_NUMBER
    ; Number is on the stack. 
    ; If we're in compile mode, enclose it
    .DATA MODE_WA
    .DATA AT_WA
    .DATA STAR_IF_WA
    .DATA PROCESS_TOKENS_NUM_TO_STACK
    .DATA STAR_HASH_WA
    .DATA STAR_HASH_WA ; push the literal handler to the stack
    .DATA COMMA_WA     ; enclose it
    .DATA COMMA_WA     ; and he number

PROCESS_TOKENS_NUM_TO_STACK:
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_LOOP ; Leave the number on the stack and loop

PROCESS_TOKENS_NOT_A_NUMBER:
    .DATA STAR_HASH_WA
    .DATA MSG_UNKNOWN_TOKEN
    .DATA TYPE_WA
    .DATA DP_WA
    .DATA AT_WA
    .DATA TYPE_WA
    .DATA STAR_ELSE_WA
    .DATA PROCESS_TOKENS_LOOP

PROCESS_TOKENS_EXIT:
    .DATA SEMI

TRAP:               ; Used for debugging. Dumps the contents of the registers
                    ; But for now it just says Hello World!
  .N "TRAP"
  .DATA PROCESS_TOKENS
TRAP_WA:
  .DATA TRAP_CA
TRAP_CA:
  MOV A,PC
  ADDAI 4
  JR TRAP1
  .DATA 14
  .SDATA "Hello World!"
TRAP1:
  PUSHD A            ; Push the address of the string
  SYSCALL #SYSCALL_TYPE
  HALT
  JP NEXT

; ( addr -- len )
WORD_LEN:
  .N "WORD-LEN"
  .DATA TRAP
WORD_LEN_WA: .DATA WORD_LEN_CA
WORD_LEN_CA:
  POPD A
  LD A,A
  CLRI A,15
  CLRI A,14
  CLRI A,13
  PUSHD A
  JP NEXT  

DOT_WORD:
  .N ".WORD"
  .DATA WORD_LEN
DOT_WORD_WA: .DATA DOT_WORD_CA
DOT_WORD_CA:
  ; ( wordAddr -- )
  ; R0 - addr -> idx
  ; R1 - len
  POPD R0
  LD R1,R0 ; Len to R1
  CLRI R1,15
  CLRI R1,14
  CLRI R1,13
  ADDI R0,2 ; point to word
DOT_WORD_LOOP:
  LD_B R2,R0
  PUSHD R2
  SYSCALL #SYSCALL_PUTC
  ADDI R0,1
  ADDI R1,-1
  JR[NZ] DOT_WORD_LOOP
  JP NEXT

DOT_SWORD:
; Print a word placed on the D stack by S"
  .N ".SWORD"
  .DATA DOT_WORD
DOT_SWORD_WA: .DATA COLON
DOT_SWORD_CA:
  .DATA DOT_WORD_WA
  .DATA DOT_SWORD_CODE
DOT_SWORD_CODE: .DATA DOT_SWORD_ASM
DOT_SWORD_ASM:
  POPD R0 ; len
  ADDI R0,1
  CLRI R0,0
  SUBI R0,2
  ADD SP,R0
  JP SEMICA

NEXT_WORD:
  .N "NEXT-WORD"
  .DATA DOT_SWORD
NEXT_WORD_WA: .DATA COLON
NEXT_WORD_CA:
  ; ( addr -- addr )
  ; DUP @ + 2+ ALIGN @
  .DATA DUP_WA
  .DATA AT_WA
  .DATA STAR_HASH_WA
  .DATA 0x1fff
  .DATA AND_WA
  .DATA PLUS_WA
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA AT_WA
  .DATA SEMI


CRET:
  .N "CRET"
  .DATA NEXT_WORD
CRET_WA: .DATA CRET_CA
CRET_CA:
  MOVIL A,0x0a
  PUSHD A
  SYSCALL #SYSCALL_PUTC
  JP NEXT

WORDS:
; List all the defined words
  .N "WORDS"
  .DATA CRET
WORDS_WA: .DATA COLON
WORDS_CA:
  .DATA CURRENT_WA
  .DATA AT_WA
  .DATA AT_WA
WORDS_LOOP:
  .DATA DUP_WA ; ( addr -- addr addr)
  .DATA DOT_WORD_WA ; ( .. -- addr len )
  .DATA ASPACE_WA
  .DATA EMIT_WA
  ; Now skip up to the next word
  .DATA NEXT_WORD_WA
  .DATA DUP_WA
  .DATA NOT_WA
  .DATA STAR_IF_WA
  .DATA WORDS_LOOP
  .DATA DROP_WA
  .DATA SEMI


; Search the dictionary for the current token
; Searches the vocabulary pointed to by CURRENT
; Return the WA on the stack if a match is found, or zero
SEARCH:
    .N "SEARCH"
    .DATA WORDS
SEARCH_WA:
    .DATA SEARCH_CA
SEARCH_CA:

  ; DP in I R0
  MOVIL A,%DICTIONARY_POINTER
  LD R0,A

  ; Token length in WA R1
  LD R1,R0
  ; Bump I to point to first char
  ADDI R0,2
  MOV R6,R0

  ; Use CA R2 to point to the current word
  MOVIL R2,%CURRENT
  LD R2,R2
  LD R2,R2

SEARCH_NEXT:
  MOV R0,R6
  LD A,R2  ; get the length of the word
  CLRI A,15 ; Clear the immediate bit if it's set
  CLRI A,14 ; Clear the immediate bit if it's set
  CLRI A,13 ; Clear the run-time bit if it's set
  CMP A,R1 ; Same as the token?
  JR[Z] SEARCH_COMPARE
  ; Not the same, move to the next word
  ADD R2,A
  ADDI R2,3 ; CA now points to the link address
  CLRI R2,0  ; make sure it's a word address
  LD R2,R2 ; Now point to the next word
  AND R2,R2 ; Is it zero?
  JR[NZ] SEARCH_NEXT

SEARCH_EXIT:
  ; Not found so leave the bufferr address zero on the stack and exit
  MOVI A,0
  PUSHD A
  JP NEXT

SEARCH_COMPARE:
  ; Test the strings for equality
  MOV R3,R2 ; Save the current word location
  ADDI R2,2 ; Point to the string
  MOV R4,R1 ; Length to R4 for the counter

SEARCH_COMPARE_LOOP:
  LD_B A,R0
  LD_B B,R2
  CMP A,B
  JR[NZ] SEARCH_COMPARE_FAIL
  ADDI R2,1
  ADDI R0,1
  ADDI R4,-1
  JR[NZ] SEARCH_COMPARE_LOOP
SEARCH_COMPARE_FOUND:
  PUSHD R3 ; Name address to the stack
  MOVI A,1
  PUSHD A   ; And a true flag
  JP NEXT

SEARCH_COMPARE_FAIL:
  LD A,R3  ; get the length of the word
  CLRI A,15 ; Clear the header bit
  CLRI A,14 ; Clear the immediate bit if it's set
  CLRI A,13 ; Clear the run-time bit if it's set
  ; Move to the next word
  ADD R3,A
  ADDI R3,3 ; CA now points to the link address
  CLRI R3,0  ; make sure it's a word address
  LD R2,R3 ; Now point to the next word
  AND R2,R2 ; Is it zero?
  JR[NZ] SEARCH_NEXT
  JR SEARCH_EXIT

TWO_DOTS: ; This is the public COLON routine
  .N ":"
  .DATA SEARCH
TWO_DOTS_WA: .DATA COLON
TWO_DOTS_CA:
  .DATA CURRENT_WA
  .DATA AT_WA
  .DATA CONTEXT_WA
  .DATA STORE_WA
  .DATA CREATE_WA
  .DATA STAR_HASH_WA
  .DATA COLON
  .DATA CASTORE_WA
  .DATA STAR_HASH_WA
  .DATA 1
  .DATA MODE_WA
  .DATA STORE_WA
  .DATA SEMI


LIT:
  .I ".\""
  .DATA TWO_DOTS
LIT_WA: .DATA COLON
LIT_CA:
  .DATA STAR_HASH_WA .DATA STAR_LIT_WA 
  .DATA COMMA_WA
  .DATA STAR_HASH_WA .DATA 0x22
  .DATA TOKEN_WA
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA DP_WA
  .DATA PLUS_STORE_WA
  .DATA SEMI

S_LIT: 
; String literal
; At compile-time, builds the string into the dictionary
; At run-time (i.. at the command-line ) moves the string
; to the return stack
  .X "S\""
  .DATA LIT
S_LIT_WA: .DATA COLON
S_LIT_CA:
  .DATA MODE_WA
  .DATA AT_WA
  .DATA STAR_IF_WA .DATA S_LIT_RUNTIME
  ; compile-time
  .DATA STAR_HASH_WA .DATA STAR_S_LIT_WA
  .DATA COMMA_WA
  .DATA STAR_HASH_WA .SDATA "\""
  .DATA TOKEN_WA ; Move the string to the dictionary
  .DATA TWO_PLUS_WA
  .DATA ALIGN_WA
  .DATA DP_WA
  .DATA PLUS_STORE_WA
  .DATA STAR_ELSE_WA .DATA S_LIT_DONE
S_LIT_RUNTIME:
  ; runtime - move the string to the return stack
  .DATA STAR_HASH_WA .SDATA "\""
  .DATA TOKEN_WA ; Move the string to the dictionary
  .DATA DROP_WA
  .DATA S_LIT_CODE
S_LIT_CODE: .DATA S_LIT_ASM
S_LIT_ASM:
  .ALIAS R0,DP
  .ALIAS R1,SDP
  .ALIAS R2,IDX
  .ALIAS R3,LEN
  .ALIAS R4,TMP
  .ALIAS R5,WRD

  MOVIL DP,%DICTIONARY_POINTER
  LD SDP,DP
  LD LEN,SDP
  ADDI LEN,3
  CLRI LEN,0 ; Word align
  MOV IDX,LEN
  SUB SP,LEN ; Take space on the  stack
  ADDI SP,2  ; Back up to align the stack pointer
S_LIT_LOOP:
  LD TMP,SDP
  ST SP,TMP
  ADDI SDP,2
  ADDI SP,2
  ADDI IDX,-2
  JR[NZ] S_LIT_LOOP
  SUB SP,LEN ;
  MOV WRD,SP
  ADDI SP,-2
  PUSHD WRD   ; Push the return stack pointer to the data stack ready for .WORD
S_LIT_CODE_DONE:
  JP SEMICA

; Exit for the compile code
S_LIT_DONE:
  .DATA SEMI

STAR_S_LIT:
  .R "*S\""
  .DATA S_LIT
STAR_S_LIT_WA: .DATA STAR_S_LIT_CA
STAR_S_LIT_CA:
  MOV A,I
  LD B,I
  ADD I,B
  ADDI I,3
  CLRI I,0 ; Word align
  PUSHD A
  JP NEXT

QUESTION:
  .N "?"
  .DATA STAR_S_LIT
QUESTION_WA: .DATA COLON
QUESTION_CA:
  .DATA STAR_LIT_WA
  .DATA 1
  .SDATA "?"
  .DATA RESTART_WA
  .DATA SEMI

TICK: ; ( -- wa )
  .N "'"
  .DATA QUESTION
TICK_WA: .DATA COLON
TICK_CA:
  .DATA ASPACE_WA
  .DATA TOKEN_WA
  .DATA DROP_WA
  .DATA SEARCH_WA
  .DATA NOT_WA 
  .DATA STAR_IF_WA
  .DATA TICK_DONE 
  .DATA QUESTION 
TICK_DONE:
  .DATA WA_TO_CA_WA
  .DATA  SEMI

N_TICK: ; ( -- na )
  .N "N'"
  .DATA TICK
N_TICK_WA: .DATA COLON
N_TICK_CA:
  .DATA ASPACE_WA
  .DATA TOKEN_WA
  .DATA DROP_WA
  .DATA SEARCH_WA
  .DATA NOT_WA 
  .DATA STAR_IF_WA
  .DATA N_TICK_DONE 
  .DATA QUESTION 
N_TICK_DONE:
  .DATA  SEMI

FORGET: 
  .N "FORGET"
  .DATA N_TICK
FORGET_WA: .DATA COLON
FORGET_CA:
.DATA CURRENT_WA .DATA AT_WA .DATA CONTEXT_WA .DATA STORE_WA
.DATA N_TICK_WA      ; Get the address of the word to forget
.DATA DUP_WA       ; copy it
.DATA NEXT_WORD_WA ; address of previous word
.DATA CURRENT_WA .DATA AT_WA
.DATA STORE_WA     ; Reset the current vocab
.DATA DP_WA
.DATA STORE_WA     ; And the dictionary pointer
.DATA SEMI

STATE:
  .N "STATE"
  .DATA FORGET
STATE_WA:
  .DATA STATE_CA
STATE_CA:
  .ALIAS A,STATE
  MOVIL STATE,%STATE
  PUSHD STATE
  JP NEXT


BACKSLASH: ; Forth word delimiting a \ comment 
  .X "\\"
  .DATA STATE
BACKSLASH_WA: .DATA COLON
BACKSLASH_CA:
  .DATA STAR_HASH_WA
  .DATA 92 ; The backslash character
  .DATA TOKEN_WA
  .DATA DROP_WA
  .DATA SEMI

PAREN: ; Forth word delimiting a ( comment )
  .X "("
  .DATA BACKSLASH
PAREN_WA: .DATA COLON
PAREN_CA:
  .DATA STAR_HASH_WA
  .DATA 41
  .DATA TOKEN_WA
  .DATA DROP_WA
  .DATA SEMI

CSPLIT:
  .N "CSPLIT"
  .DATA PAREN
CSPLIT_WA: .DATA CSPLIT_CA
CSPLIT_CA:
; Split the TOS into two bytes
; ( word -- l h )
  POPD A
  MOV B,A
  MOVIL R0,0x00ff
  AND A,R0
  SRI B,8
  PUSHD A
  PUSHD B
  JP NEXT

DOT_TWO_BYTES:
  .N ".2BYTES"
  .DATA CSPLIT
DOT_TWO_BYTES_WA: .DATA COLON
DOT_TWO_BYTES_CA:
  .DATA CSPLIT_WA
  .DATA SWAP_WA
  .DATA DOT_C_WA .DATA ASPACE_WA .DATA EMIT_WA 
  .DATA DOT_C_WA
  .DATA SEMI 

DUMP:
  .N "DUMP"
  .DATA CSPLIT
DUMP_WA: .DATA COLON
DUMP_CA:
  ; Dump the word whose address is on the stack
  ; ( WA numBytesToDump -- )
  .DATA OVER_WA
  .DATA PLUS_WA
  .DATA SWAP_WA
  .DATA STAR_DO_WA
DUMP_LOOP:
  .DATA INDEX_I_WA .DATA AT_WA ; data
  .DATA INDEX_I_WA             ; address
  .DATA DOT_WA
  .DATA ASPACE_WA .DATA EMIT_WA
  .DATA DUP_WA
  .DATA CSPLIT_WA
  .DATA SWAP_WA
  .DATA DOT_C_WA .DATA ASPACE_WA .DATA EMIT_WA .DATA DOT_C_WA ; print the values
  .DATA CSPLIT_WA
  .DATA SWAP_WA
  .DATA ASPACE_WA .DATA EMIT_WA
  .DATA EMIT_WA .DATA ASPACE_WA .DATA EMIT_WA .DATA EMIT_WA ; and the characters
  .DATA CRET_WA
  .DATA STAR_HASH_WA .DATA 2
  .DATA STAR_PLUSLOOP_WA .DATA DUMP_LOOP
  .DATA SEMI

FOPEN:
  .N "FOPEN"
  .DATA DUMP
FOPEN_WA: .DATA FOPEN_CA
FOPEN_CA:
  SYSCALL #SYSCALL_FOPEN
  JP NEXT

FCLOSE:
  .N "FCLOSE"
  .DATA FOPEN
FCLOSE_WA: .DATA FCLOSE_CA
FCLOSE_CA:
  SYSCALL #SYSCALL_FCLOSE
  JP NEXT

FREAD:
  .N "FREAD"
  .DATA FCLOSE
FREAD_WA: .DATA FREAD_CA
FREAD_CA:
; ( -- bytes-read )
; Put the address of the line buffer on the stack
  MOVIL A,%LBUF_IDX
  PUSHD A
  SYSCALL #SYSCALL_FREAD
  JP NEXT

FEOF:
  .N "FEOF"
  .DATA FREAD
FEOF_WA: .DATA COLON
FEOF_CA:
  .DATA STAR_HASH_WA .DATA -1
  .DATA SEMI

READ_FILE:
  .N "READ_FILE"
  .DATA FEOF
READ_FILE_WA: .DATA COLON
READ_FILE_CA:
  ; ( address-of-filename -- )
  .DATA STAR_HASH_WA .DATA 0
  .DATA FOPEN_WA
  .DATA STAR_IF_WA .DATA READ_FILE_FAILED_OPEN
READ_FILE_LOOP:
  .DATA FREAD_WA
  .DATA FEOF_WA
  .DATA NOT_EQUALS_WA
  .DATA STAR_IF_WA .DATA READ_FILE_DONE
  .DATA PROCESS_TOKENS_WA
  .DATA STAR_ELSE_WA
  .DATA READ_FILE_LOOP
READ_FILE_FAILED_OPEN:
  .DATA STAR_LIT_WA .DATA 16
  .SDATA "Cannot open file"
  .DATA SEMI
READ_FILE_DONE:
  .DATA STAR_HASH_WA .DATA 0
  .DATA FCLOSE_WA
  .DATA SEMI



; The last word in the dictionary placed at the end of ROM before RAM starts
.ORG #FENCE
CORE_VOCABULARY:
FENCE:
  
  .X "FENCE"
  .DATA READ_FILE
FENCE_WA: .DATA COLON
FENCE_CA:
  .DATA SEMI


DICTIONARY_END:
    .DATA 00
